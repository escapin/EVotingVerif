Joana Verification Progress - Juergen Graf <graf@kit.edu>
---------------------------------------------------------

1. commit ca6b1d829692188c0c6717e8898f4119250414e7

Convert to Java 1.4, because runtime libraries are far smaller and thus our
whole-program analysis runs faster and is more precise, because less over-
appproximations are needed.

2. First verification attempt shows multiple security leaks. We traced them
back to the array reference of voiterChoices being tainted. Because of
possible NullPointerExceptions and IndexOutOfBoundsExceptions illegal flow is
detected.

3. commit a7e0721f61a941cbfc80d404ecec7b306f7a5c67

Explicitly copy values of the voterChoices(1|2) arrays, because simply
switching array references due to secret information also taints the array
base pointer in our approach. But the secret information is not where the
array is stored in memory, only  which values it holds.

4. A single security leak is found, as the result contains about
Server.votesForA and Server.votesForB. The killing definitions in line 44f
could not be detected, thus we assume that both members are still tainted.

We propose 2 solutions: 
  4.1. Improve detection of killing definitions.
       (We started working in this issue by now)
  4.2. Change code of getResult, to make use of correctResult.votesFor(A|B)
       more explicit. (See next step)

5. commit 768a6738a3befa71916f082b018b7b21b257b3a7

After changing the code as proposed in 4.2 we can verify noninterference for this program.

6. commit 5cbc222583d9ab6f03b7790620c5c44278c4d29c

An improved analysis for local killing definitions enables Joana now to
verify the non-interference of the original getResult() code from the master branch.

 1	public byte[] getResult() {
 2		// Declassification assignments:
 3		votesForA = PassiveAdvSetup.correctResult.votesForA;
 4		votesForB = PassiveAdvSetup.correctResult.votesForB;
 5
 6		byte[] result =  MessageTools.concatenate(
 7							MessageTools.intToByteArray(votesForA),
 8							MessageTools.intToByteArray(votesForB));
 9		
10//		this.votesForA = votesForA;
11//		this.votesForB = votesForB;
12		
13		return result;
14	}

We can now detect, that the read operations (votesFor(A|B)) in line 7 and 8 only
depend on the values set in lines 3 and 4 and never on the values previously stored
in both attributes.
